## System Model 
## Deadlock Charactierization
- 每個資源稱為 R，像是 I/O 或是記憶體
- R 則有 W 個 instances
- 每個資源使用在三種方法順序 request、use、release
### Characterization
如果有以下四種情況，則形成 Deadlock
- Mutual exclusion
	- 表示資源不可共享時，一次只能有一個 process 使用資源
- Hold and wait
	- 一個 process 已獲得一個資源，但它有在等待另一個資源
- No preemption
	- 當資源不可搶占時
	- 如果我們允許搶佔，則阻塞的 process 就可以得到資源完成並且釋放
- Circular wait
	- 循環等待
### Example of a resource allocation graph
No Deadlock
![[Pasted image 20251117155047.png|500]]
Deadlock happen
![[Pasted image 20251117155223.png|500]]
- 最大的差別是因為P3需要R2，造成了循環等待
No Deadlock
![[Pasted image 20251117155739.png|500]]
- 無循環，所以資源可以等待資源完成釋放

### Basic Facts
- no cycle
	- no deadlock
- cycle
	- only one instance per resource type $\rightarrow$ deadlock
	- several instances $\rightarrow$ possibility of deadlock
## Methods for Handling Deadlocks
- 兩種方法解決 Deadlock
	- 系統夠智能，可以提前做到 Deadlock prevention、Deadlock avoidence
	- 允許 deadlock 發生，但系統可以偵測以及恢復 Deadlock 的情況
## Deadlock Prevention
- 確保系統永遠不會進入 deadlock 的情況
- 所以它確保 deadlock 的條件不滿足
	- Mutual Exclusion
		- 限制必須是不可共享資源
	- Hold and Wait
		- 限制在請求資源時，不能佔用資源
		- 像是哲學家問題，一次就要拿完所有的資源
		- 資源利用率低、Starvation
	- No Preemption
		- 讓資源可以被搶佔，使得 process 可以盡快得到資源並且釋放
		- 這裡指的不是搶佔其他人的資源，而是釋放自己的資源
	- Circular Wait
		- 將資源由小到大編號。當 process 請求資源時，需要遵循順序請求資源，像是由小至大的資源佔量
- 可能會影響系統的效能，像是資源利用率等
## Deadlock Avoidance
- 採用一種有效的方法，避免 deadlock
- 需要一些額外資訊，像是
	- 每個 process 需要多少資源( 它可能需要 2 張網路卡、3 個硬碟等 )
	- 動態檢查資源分配狀態，紀錄資源數量、已使用的資源數量、每個 process 需要多少資源
- 預先檢測循環狀態，透過演算法分配資源，檢查確保沒有 deadlock 或是 circular wait 發生
### Safe State
- 存在一個順序，所有 process 可以透過這個順序完成各自的任務
- 有一個限制，序列中先完成的 process 必須釋放資源
- 在 Safe State 中，可以確保不會 deadlock 的發生
![[Pasted image 20251117163828.png|500]]
### Resource-Allocation Graph Scheme
- 每種資源只有一個 instance，像是只有一個顯示器等
- Claim edge : $P_i \rightarrow R_j$ ，表示 $P_i$ 需要 $R_j$ ，表示是一個 bogus request (虛假請求)
- 當請求發生時，claim edge 會變成 request edge
- 將資源分配後，request edge 會變成 assignment edge
- 資源被釋放後，assignment edge 會重新變成 claim edge
- 必須先認領資源後，才可以使流程執行
![[Pasted image 20251117185404.png|250x250]]
- safe state
![[Pasted image 20251117185432.png|250x250]]
- unsafe state
- 因為唯一的虛線若是實作出來，則會 deadlock，所以禁止

- 系統會決定是否要給予資源，確保資源分配圖不會有 cycle 的情況
![[Pasted image 20251117190213.png|500]]
### Banker's algorithm
- 資源會有多個 instance，像是多個硬碟
- 當演算法找不到一個順序解法的話，系統則不允許進行分配資源
- Define
	- 每個 process 都要先聲明最大使用多少資源
	- 當一個 process 請求資源時，必須等待
	- 當 process 得到所有需要資源後，要在有限時間歸還
- Variable
	- $n$ : Process 的數量
	- $m$ : 資源類型數
	- **Available**
		- 一個陣列
		- 每種資源的可用 instances
		- `available[j] = k
			- 在 $R_j$ 這個資源有 $k$ 個 instances 可以用，`len(available)` 長度 $m$
	- **Max**
		- 一個矩陣
		- process 的 request instance 的編號
		- `Max[i,j] = k` 
			- Process $i$ 最多可以請求 $k$ 個 instances
	- **Allocation**
		- 一個矩陣
		- 已分配給多少資源
		- `Allocation[i,j] = k`
			- Process $i$ 目前已經請求 $k$ 個 instances
	- **Need**
		- 一個矩陣
		- 還需要多少資源
		- `Need[i,j] = k`
			- Process $i$ 需要 $k$ 個 instances
		- `Need[i,j] = Max[i,j] - Allocation[i,j]`
#### Safety Algorithm
- 目的是為了找到順序
![[Pasted image 20251117192132.png|500]]
![[Pasted image 20251117192449.png|500]]
#### Example 
![[Pasted image 20251117192810.png|500]]
![[Pasted image 20251117193043.png|500]]
## Deadlock Detection
- 用一個偵測 deadlock 的演算法，並且設計一個根據恢復方案恢復 deadlock 狀態
### Single instance
- **wait-for** graph
- $P_i \rightarrow P_j$ 表示 $P_i$ 在等待 $P_j$ ，然後演算法定期檢查圖表，看是否有 cycle
![[Pasted image 20251117194121.png|500]]
### Multiple instances
- 跟 Banker's algorithm 相同
- **Available**
	- 表示資源的可用 instance 數量
- **Allocation**
	- 以分配的資源
- **Request**
	- 目前請求的資源量
![[Pasted image 20251117194737.png|500]]
![[Pasted image 20251117195018.png|500]]
- 透過演算法，動態了解目前的狀況，對於 b 每個 process 進行檢查並且分配
- 透過 Allocation 來阻止有人就算沒資源還要進來搶資源造成 deadlock 的情況
#### Example 
- 邏輯正常，不會造成 deadlock
![[Pasted image 20251117195322.png|500]]
- 若在 Request 不正常時，會有 deadlock 產生

![[Pasted image 20251117195439.png|250]]
## Recovery from Deadlock
- 處理 deadlock 
	- 終止所有 deadlock process
	- 逐一終止過程，直到 deadlock 消失，選定的 process 會在被終止時歸還資源，有更多資源打破 deadlock
- 如何選擇誰該被終止
	- 優先權
	- 可以看執行時間或是剩餘時間
	- 耗費大量資源的 process
### Recovery
- Selecting a victim
	- cost minmum
- Rollback
	- 將 deadlock 變成 safe state
	- 可能會造成 starvation
- Starvation
	- 透過 aging 等方法解決