### Objectives
- 為了不讓 CPU 空閒，我們需要先把 processes 放入記憶體，放到 ready queue
- Process sheduling 是一種從 ready queue 選擇合適的 process 使用 CPU 的演算法
## Basic Concepts
- 為了最大限度使用 CPU
- CPU burst ( CPU working ) 會伴隨 I/O burst ( CPU idling )
- 大部分的 CPU burst 時長都非常短
### CPU Scheduler
- Short-term scheduler
- When 
	- Running $\rightarrow$ Waiting : I/O or other event ( nonpreemptive )
	- Running $\rightarrow$ Ready : Interrupt ( preemptive )
	- Waiting $\rightarrow$ Ready : 可以檢查優先權，安排進入 Ready queue ( preemptive )
	- Terminated : 可以執行其他 process ( nonpreemptive )
### Dispatcher 
- Software 
- 將 CPU 執行權給目標 process，需要做 context switch
- 包含 Process ID、CPU register、stack、data structure

- **Dispatch latency** 
	- 在做 Context switch 需要時間，所以會有時間延遲
	- 在停止一個 process 到啟動另一個 process
	- 所以頻繁 switch 是不好的
## Scheduling Criteria 
- CPU utilization
	- 為了讓 CPU 盡可能忙碌
- Throughtput
	- 每單位時間內平均完成 processes 的工作量
- Turnaround time
	- 整個過程開始到結束的時間
	- 各種 state 到 terminate
- Waiting time
	- 花費在 ready queue 的時間
- Response time
	- 從開始到第一次執行的時間
## Scheduling Algorithms
### FCFS ( First Come First Serve )
- 先來的先服務，所以後面的要等所有前面的完成
- 如果順序好的話，可以有很好的 waiting time
- **Convoy effect**
	- 有可能會有 short process 要等前面的 long process
	- 順序就是要看運氣
![[Pasted image 20251012144030.png]]
![[Pasted image 20251012144041.png]]
- 不靈活
### SJF ( Shortest-Job-First )
- 最先服務最短的 process
- 很難得知下一個 process 多長
	- 看 code 的長度，但可能當中迴圈很多
![[Pasted image 20251012144655.png]]
- 主要問題還是在如何找到最短解
	- 我們只能估計長度
	- Exponential averaging
	- $\tau_{n+1} \ = \ \alpha t_n + (1-\alpha)\tau_n$
		![[Pasted image 20251012144947.png|300]]
		- $\alpha$ 大多設為 $\frac{1}{2}$
#### Shortest-remaining-time-first
- preemption 搶佔
- 在 Process 進到 Ready queue 中，演算法會將短的搶占 CPU 使用
![[Pasted image 20251012145833.png]]
### Priority Schduling
- 根據優先度決定執行順序
- 也有
	- Preemptive
	- Non-preemptive
+ 會有 **Starvation**，就是優先度太低，可能永遠執行不到
	+ Sol: **Aging** 在一段時間，提高未執行的優先度
### RR ( Round-Robin )
- **n** process，**q** time quantum
- 每個 process 有 $\frac{1}{n}$ CPU time，最多可以有 q 個時間單位
- 不會有一個 process 會等待超過 (n-1)\*q 的時間
- q 的大小可能會造成
	- 過大 $\rightarrow$ **FIFO**
	- 過小 $\rightarrow$ ( context switch ) **overhead** increases，過多的 context switch
- 時間單位設的多大，無法減少 turnaround time
### Multilevel Queue Scheduling
- 前面的演算法只考慮一個序列調度
- 有些執行需要多的 interactive，另一則大 batch
- 所以可以分別兩個序列
	- foreground
	- background
- 問題
	1. 固定優先度，哪個序列需要先執行，可能造成 starvation
	2. Time slice，分配時間比例
### Multilevel Feedback Queue Scheduling
- 可以**動態調整**執行的序列
- 可視參數
	- number of queues
	- scheduling algorithms for each queue
	- method used to determine upgrade
	- method used to determine demote
	- method used to determine assign new process
## Thread Scheduling
- PCS ( process-contention scope )
	- 競爭同一個 process
- SCS ( system-contention scope )
	- 競爭的是整個系統的 process
### Pthread Scheduling
- 可以用 API 指定 PCS 以及 SCS 的模式
	- PTHEAD_SCOPE_PROCESS、PTHREAD_SCOPE_SYSTEM
	- 在 M2M 的時候，綁定 LWP
## Multiple-Processor Scheduling
- 我們只關注 Homogeneous processors，理想上每個 process 的效率都一樣

- Asymmetric multiprocessing ( AMP ) 非對稱
	- 指定一個 processor 作為 master，負責調度 tasks
	- 其餘只需要執行就好
- Symmetric multiprocessing ( SMP ) 對稱
	- 每個 process 都會自己調度

- Processor affinity
	- soft affinity : 任何的 process 都可以被所有的 processor 處理
	- hard affinity : 只能被同一 processor 處理
### NUMA ( non-uniform memory access ) and CPU
- 當有多個 CPU 並且每個 CPU 都有自己的 memory
- 用 hard affinity 的話，會減少訪問時間

### Multicore Processors
- 一個 CPU 但有多個 cores
- 可以解決 Memory stall ( 記憶體停頓 )
	- 存取記憶體會有時間延遲
	- 可以用另一個 thread 做解決問題

## Operating System Examples
### Solaris
- Priority-based thread scheduling
- 總共有六個等級
	- Time sharing ( default ) ( TS )
	- Interacitve ( IA )
	- Real time ( RT )
	- System ( SYS )
	- Fair Share ( FSS )
	- Fixed priority ( FP )
- 越高優先級的，能執行的時間越少
 ![[Pasted image 20251012161231.png|400]]
### Windows Scheduling 
- Priority-based thread scheduling & Preemptive 
- 可以執行到結束或是被搶占
- 有 32 個優先等級
	- 1-15 變數
	- 16-31 即時
	- 0 記憶體管理線程
- 如果沒有 thread 可以執行，會提供一個 idle thread
![[Pasted image 20251012161904.png|400]]
### Linux Scheduling
- Priority-based thread scheduling & Preemptive 
- 140 個優先等級
	- 0-99 即時
	- 100-139 nice value
- 數字越小，優先級越高
![[Pasted image 20251012162205.png|400]]
- 每個優先級都是一個 link list
## Algorithm Evaluation
+ Deterministic modeling
	+ 根據歷史的 Burst time，並且嘗試所有的演算法，最後選擇演算法
	+ 先確定注重的點是什麼，選擇哪一種的演算法
+ Queueing model
	+ 用統計方法，建立方程式，對於所有參數建立
	+ 數理分析
+ Simulation
	+ 會有一個模擬器做調度，統計資料
	+ 隨機數模擬
	![[Pasted image 20251012162922.png|400]]
+ Implementation
	+ 將演算法放進實際的系統中，了解實際效能，但這樣會花費很多時間、資源、人力
	+ 實作之後，繼續觀察
