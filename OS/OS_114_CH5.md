### Objectives
- 為了不讓 CPU 空閒，我們需要先把 processes 放入記憶體，放到 ready queue
- Process sheduling 是一種從 ready queue 選擇合適的 process 使用 CPU 的演算法
## Basic Concepts
- 為了最大限度使用 CPU
- CPU burst ( CPU working ) 會伴隨 I/O burst ( CPU idling )
- 大部分的 CPU burst 時長都非常短
### CPU Scheduler
- Short-term scheduler
- When 
	- Running $\rightarrow$ Waiting : I/O or other event ( nonpreemptive )
	- Running $\rightarrow$ Ready : Interrupt ( preemptive )
	- Waiting $\rightarrow$ Ready : 可以檢查優先權，安排進入 Ready queue ( preemptive )
	- Terminated : 可以執行其他 process ( nonpreemptive )
### Dispatcher 
- Software 
- 將 CPU 執行權給目標 process，需要做 context switch
- 包含 Process ID、CPU register、stack、data structure

- **Dispatch latency** 
	- 在做 Context switch 需要時間，所以會有時間延遲
	- 在停止一個 process 到啟動另一個 process
	- 所以頻繁 switch 是不好的
## Scheduling Criteria 
- CPU utilization
	- 為了讓 CPU 盡可能忙碌
- Throughtput
	- 每單位時間內平均完成 processes 的工作量
- Turnaround time
	- 整個過程開始到結束的時間
	- 各種 state 到 terminate
- Waiting time
	- 花費在 ready queue 的時間
- Response time
	- 從開始到第一次執行的時間
## Scheduling Algorithms
### FCFS ( First Come First Serve )
- 先來的先服務，所以後面的要等所有前面的完成
- 如果順序好的話，可以有很好的 waiting time
- **Convoy effect**
	- 有可能會有 short process 要等前面的 long process
	- 順序就是要看運氣
![[Pasted image 20251012144030.png]]
![[Pasted image 20251012144041.png]]
- 不靈活
### SJF ( Shortest-Job-First )
- 最先服務最短的 process
- 很難得知下一個 process 多長
	- 看 code 的長度，但可能當中迴圈很多
![[Pasted image 20251012144655.png]]
- 主要問題還是在如何找到最短解
	- 我們只能估計長度
	- Exponential averaging![[Pasted image 20251012144947.png]]
		- $\alpha$ 大多設為 $\frac{1}{2}$
#### Shortest-remaining-time-first
- preemption 搶佔
- 在 Process 進到 Ready queue 中，演算法會將短的搶占 CPU 使用
![[Pasted image 20251012145833.png]]
### Priority Schduling
- 根據優先度決定執行順序
- 也有
	- Preemptive
	- Non-preemptive
+ 會有 **Starvation**，就是優先度太低，可能永遠執行不到
	+ Sol: **Aging** 在一段時間，提高未執行的優先度
### RR ( Round-Robin )
- **n** process，**q** time quantum
- 每個 process 有 $\frac{1}{n}$ CPU time，最多可以有 q 個時間單位
- 不會有一個 process 會等待超過 (n-1)\*q 的時間
- q 的大小可能會造成
	- 過大 $\rightarrow$ **FIFO**
	- 過小 $\rightarrow$ ( context switch ) **overhead** increases，過多的 context switch
- 時間單位設的多大，無法減少 turnaround time
### Multilevel Queue Scheduling
- 前面的演算法只考慮一個序列調度
- 有些執行需要多的 interactive，另一則大 batch
- 所以可以分別兩個序列
	- foreground
	- background
- 問題
	1. 固定優先度，哪個序列需要先執行，可能造成 starvation
	2. Time slice，分配時間比例
### Multilevel Feedback Queue Scheduling
- 可以**動態調整**執行的序列
- 可視參數
	- number of queues
	- scheduling algorithms for each queue
	- method used to determine upgrade
	- method used to determine demote
	- method used to determine assign new process
## Thread Scheduling
- PCS ( process-contention scope )
	- 競爭同一個 process
- SCS ( system-contention scope )
	- 競爭的是整個系統的 process
### Pthread Scheduling
- 可以用 API 指定 PCS 以及 SCS 的模式
	- PTHEAD_SCOPE_PROCESS、PTHREAD_SCOPE_SYSTEM
	- 在 M2M 的時候，綁定 LWP
## Multiple-Processor Scheduling
- 我們只關注 Homogeneous processors，理想上每個 process 的效率都一樣

- Asymmetric multiprocessing ( AMP ) 非對稱
	- 指定一個 processor 作為 master，負責調度 tasks
	- 其餘只需要執行就好
- Symmetric multiprocessing ( SMP ) 對稱
	- 每個 process 都會自己調度

- Processor affinity
	- soft affinity : 任何的 process 都可以被所有的 processor 處理
	- hard affinity : 只能被同一 processor 處理

## Operating System Examples

## Algorithm Evaluation

