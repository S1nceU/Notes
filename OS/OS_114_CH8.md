- 介紹 memory 管理的不同方式以及不同的硬體組成
- 介紹 Paging 以及 Segmentation
## Background
- 執行一個程式，就需要將程式放進 memory 中
- Program $\rightarrow$ Memory $\rightarrow$ Process
- CPU 只能存取 Memory 跟 Register，其餘不行
- CPU 只能從 Memory 執行 Process，讀取資料在 Register 
- Memory 讀取會造成 Memory Stall 的延遲，用 Cache 嘗試加速存取時間
- 保護 Memory 是為了確保正確的操作
### Base and Limit Register
- base register、limit register
![[Pasted image 20251124142926.png|500]]
### Address binding
- When Program become a Process，指令跟資料會被存入 Memory
- Address binding 決定了全部的東西放到哪個 Memory address
- Stages
	- **Compile time**
		- 在編譯時，已經決定好記憶體放置位置，稱為 **Absolute code**
	- **Load time**
		- 若記憶體位置在編譯時未知，此時會給予**相對**於程式的起始位置，還沒有一個實體位置，稱為 **Relocatable code**
		- 如果想要更新 process 的位置，需要花費時間呼叫 loader 重新載入 process
	- **Execution time**
		- 當程式執行時，他終究會知道被放置在哪個實體記憶體位置
		- 並可以在執行期間由 OS 在 Memory 中移動位置
#### Logical vs. Physical Address Space
- 當 CPU 執行 process 的時候，需要產生一個 address 以尋找並執行內部程式
- 若由 CPU 產生，也可以意旨 virtual address，稱為 **Logical address**
- 可以用實體位置找尋 process 的位置，Memory 所看到的位置則為 **Physical address**
- 平常使用，OS 需要將 Logical address 翻譯成 physical address 才可以使用
- 只有在 Absolute code 時，Logical address == Physical address
#### Memory-Management Unit (MMU)
- 是一個硬體組件
- 它可以將 Logical address (virtual address) 翻譯成 Physical address，重新定位暫存器的位置
- 當 CPU 產生 logical address 後，可以透過 MMU 映射 physical address 到 memory 中，使 CPU 可以執行或存取 process
![[Pasted image 20251124172730.png|500]]
#### Dynamic Loading
- 將所有函式都打包進 memory 中，會讓很多用不到的東西也一同載入，會浪費資源，所以出現了 **Dynamic Loading**
- 當函式被呼叫的時候，他才會被載入到 memory 中
- 一句話：將有用的東西載入到記憶體中，幫助最小化資源包
#### Dynamic Linking
- 為了不要重複載入同一個東西，有了 Linking
- 將一份程式碼副本放進 memory 中並且分享它
- 為了達到特性，有兩種編譯方法
	- static linking
		- 將所有需要的 LIB 連結起來，並將整個套件連結到 loader 上
		- 快，但 COST 高
	- dynamic linking
		- windows 的 DLL 檔案是個例子，在過程中需要時才載入到記憶體
		- 使用一小段稱為 **stub** 的程式碼
		- stub 
			- 會用程式的位置來取代自己，並執行程式
			- 像是一個 proxy
		- 必須在其執行時間處理 LIB 的連結，所以會影響執行時間
## Swapping
- 當 OS 發現有 process 在等待 IO 或是暫停，就可以把它們移到 disk 上，然後釋放 memory 的空間，稱為 swap out
- 載入則為 swap in
- Backing store 
	- 備份儲存提供記憶體直接存取這些 copies
- Roll out, roll in
	- Priority-based scheduling algorithm
	- 將低優先權的 process 替換成較高優先權的 process
- 助於記憶體管理
- 傳輸記憶體資料會花費時間，傳輸時間跟記憶體大小相關
- Ready queue 會存放紀錄要更換的 process
![[Pasted image 20251124221250.png|500]]
## Contiguous Memory Allocation
- Low address $\rightarrow$ OS
- 其餘的記憶體 $\rightarrow$ 使用者的 process
- 所以需要確保作業系統不會使用過多的記憶體空間，以便使用者有更多的 memory

### Base register 以及 limit register
- 建立 process 可以存取的範圍
- limit 可以用來驗證請求的 address

- 先用限制，讓 CPU 要求的 address 在一個合法範圍內，否則，process 可能會存取記憶體中其他人的資料
- 如果符合規則，則用 relocation register 找出 mapp
![[Pasted image 20251124222613.png|500]]
### Multiple-partition allocation
- 有兩種版本
	- fixed-partition
		- Memory 會被劃分多個 fixed 的區塊
		- 每個區塊只會有一個 process
		- 當區塊空閒的時候，OS 會選擇一個 process 載入
	- variable-size
		- 區塊可以是非固定的
		- 可能會造成 **hole** 這個問題
			- OS 需要找一個足夠大的 hole 來儲存 process
			- 完成後，也會留下一個 hole
			- 久而久之，hole 遍佈整個記憶體，有小有大，利用率會下降
			![[Pasted image 20251125005709.png|500]]
		- 尋找 hole 的方法
			- First-fit
				- 根據 process 的大小，從上往下找到**第一個**適合的 hole
			- Best-fit
				- 找一個最符合 process 大小的 hole，留下的 hole 會是最小的
				- 看起來是優化空間使用，但留下的 hole 小的可能不能用
			- Worst-fit
				- 與 Best-fit 相反，留下的 hole 會是最大的
				- 為了其他人可以用這個 hole
### Fragmentation
- Memory 空間浪費的專有名詞
![[Pasted image 20251125101521.png|500]]
- External
	- variable-size allocation 才會發生
	- 剩餘總空間可以容納新的 process，但沒有 hole 可以塞
	- 解決方法：
		- Compaction
			- 調整 memory 的內容
			- 動態遷移，但會有 I/O 問題，所以要等 I/O 完成後，才可以調整
			- I/O 問題
				- 用 Latch job 將要調整的程式鎖上
				- 提供一個固定 OS 的 Buffer ，存放 I/O 的資料
- Internal
	- fixed-size allocation 才會發生
	- 在固定空間中，一個 process 沒有用到一整格
## Paging
- 允許 physical address 是不連續的

- physical memory 分割成 fixed-sized (512 bytes ~ 16Mbytes)，稱為 frame
- logical memory 也分割成 fixed-sized，稱為 page

- OS 會檢查 frame 是不是空的，不用管是不是連續的，會透過 Page table 對應，將 page 塞進 frame 當中
- 可以解決 external fragmentation
- 但依然有 internal fragmentation，因為不能保證 frame 的空間會全部用完


## Page Table
### Address Translation Scheme
![[Pasted image 20251125110657.png|500]]
- Page number ($p$)
	- index number of the page
- Page offset ($d$) 
	- 偏移量，轉換成 physical memory address

- 可以當作一本書，有一句話在 p 頁的 d 行

- m 指的是 logical address 的總位元數，所以 logical address 空間會有 $2^m$ 個位元組
- n 指的是 page offset 的位元數，單一頁大小是 $2^n$ 位元組
- page number 的位元數 m - n，page 的數量 $2^{m-n}$，offset 的範圍 $0 \sim 2^{n-1}$ 

### Paging Hardware
- MMU
	![[Pasted image 20251125112212.png|500]]
	- 用 p 來找 page table 的內容，找到 f 過後，透過 offset 找到 physical address
![[Pasted image 20251125112430.png|500]]
![[Pasted image 20251125112553.png|500]]
![[Pasted image 20251125112717.png|500]]

## Segmentation
- 
