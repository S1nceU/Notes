- 介紹 memory 管理的不同方式以及不同的硬體組成
- 介紹 Paging 以及 Segmentation
## Background
- 執行一個程式，就需要將程式放進 memory 中
- Program $\rightarrow$ Memory $\rightarrow$ Process
- CPU 只能存取 Memory 跟 Register，其餘不行
- CPU 只能從 Memory 執行 Process，讀取資料在 Register 
- Memory 讀取會造成 Memory Stall 的延遲，用 Cache 嘗試加速存取時間
- 保護 Memory 是為了確保正確的操作
### Base and Limit Register
- base register、limit register
![[Pasted image 20251124142926.png|500]]
### Address binding
- When Program become a Process，指令跟資料會被存入 Memory
- Address binding 決定了全部的東西放到哪個 Memory address
- Stages
	- **Compile time**
		- 在編譯時，已經決定好記憶體放置位置，稱為 **Absolute code**
	- **Load time**
		- 若記憶體位置在編譯時未知，此時會給予**相對**於程式的起始位置，還沒有一個實體位置，稱為 **Relocatable code**
		- 如果想要更新 process 的位置，需要花費時間呼叫 loader 重新載入 process
	- **Execution time**
		- 當程式執行時，他終究會知道被放置在哪個實體記憶體位置
		- 並可以在執行期間由 OS 在 Memory 中移動位置
#### Logical vs. Physical Address Space
- 當 CPU 執行 process 的時候，需要產生一個 address 以尋找並執行內部程式
- 若由 CPU 產生，也可以意旨 virtual address，稱為 **Logical address**
- 可以用實體位置找尋 process 的位置，Memory 所看到的位置則為 **Physical address**
- 平常使用，OS 需要將 Logical address 翻譯成 physical address 才可以使用
- 只有在 Absolute code 時，Logical address == Physical address
#### Memory-Management Unit (MMU)
- 是一個硬體組件
- 它可以將 Logical address (virtual address) 翻譯成 Physical address，重新定位暫存器的位置
- 當 CPU 產生 logical address 後，可以透過 MMU 映射 physical address 到 memory 中，使 CPU 可以執行或存取 process
![[Pasted image 20251124172730.png|500]]
#### Dynamic Loading
- 將所有函式都打包進 memory 中，會讓很多用不到的東西也一同載入，會浪費資源，所以出現了 **Dynamic Loading**
- 當函式被呼叫的時候，他才會被載入到 memory 中
- 一句話：將有用的東西載入到記憶體中，幫助最小化資源包
#### Dynamic Linking
- 為了不要重複載入同一個東西，有了 Linking
- 將一份程式碼副本放進 memory 中並且分享它
- 為了達到特性，有兩種編譯方法
	- static linking
		- 將所有需要的 LIB 連結起來，並將整個套件連結到 loader 上
		- 快，但 COST 高
	- dynamic linking
		- windows 的 DLL 檔案是個例子，在過程中需要時才載入到記憶體
		- 使用一小段稱為 **stub** 的程式碼
		- stub 
			- 會用程式的位置來取代自己，並執行程式
			- 像是一個 proxy
		- 必須在其執行時間處理 LIB 的連結，所以會影響執行時間
## Swapping
- 當 OS 發現有 process 在等待 IO 或是暫停，就可以把它們移到 disk 上，然後釋放 memory 的空間，稱為 swap out
- 載入則為 swap in
- Backing store 
	- 備份儲存提供記憶體直接存取這些 copies
- Roll out, roll in
	- Priority-based scheduling algorithm
	- 將低優先權的 process 替換成較高優先權的 process
- 助於記憶體管理
- 傳輸記憶體資料會花費時間，傳輸時間跟記憶體大小相關
- Ready queue 會存放紀錄要更換的 process
![[Pasted image 20251124221250.png|500]]
## Contiguous Memory Allocation
- Low address $\rightarrow$ OS
- 其餘的記憶體 $\rightarrow$ 使用者的 process
- 所以需要確保作業系統不會使用過多的記憶體空間，以便使用者有更多的 memory

- Base register 以及 limit register 
	- 建立 process 可以存取的範圍
	- limit 可以用來驗證請求的 address
	- 
	- 先用限制，讓 CPU 要求的 address 在一個合法範圍內，否則，process 可能會存取記憶體中其他人的資料
	- 如果符合規則，則用 relocation register 找出 map 的位置
	![[Pasted image 20251124222613.png|500]]
## Paging
- 
## Page Table
- 
## Segmentation
- 
