- 介紹 memory 管理的不同方式以及不同的硬體組成
- 介紹 Paging 以及 Segmentation
## Background
- 執行一個程式，就需要將程式放進 memory 中
- Program $\rightarrow$ Memory $\rightarrow$ Process
- CPU 只能存取 Memory 跟 Register，其餘不行
- CPU 只能從 Memory 執行 Process，讀取資料在 Register 
- Memory 讀取會造成 Memory Stall 的延遲，用 Cache 嘗試加速存取時間
- 保護 Memory 是為了確保正確的操作
### Base and Limit Register
- base register、limit register
![[Pasted image 20251124142926.png|500]]
### Address binding
- When Program become a Process，指令跟資料會被存入 Memory
- Address binding 決定了全部的東西放到哪個 Memory address
- Stages
	- **Compile time**
		- 在編譯時，已經決定好記憶體放置位置，稱為 **Absolute code**
	- **Load time**
		- 若記憶體位置在編譯時未知，此時會給予**相對**於程式的起始位置，還沒有一個實體位置，稱為 **Relocatable code**
		- 如果想要更新 process 的位置，需要花費時間呼叫 loader 重新載入 process
	- **Execution time**
		- 當程式執行時，他終究會知道被放置在哪個實體記憶體位置
		- 並可以在執行期間由 OS 在 Memory 中移動位置
#### Logical vs. Physical Address Space
- 當 CPU 執行 process 的時候，需要產生一個 address 以尋找並執行內部程式
- 若由 CPU 產生，也可以意旨 virtual address，稱為 **Logical address**
- 可以用實體位置找尋 process 的位置，Memory 所看到的位置則為 **Physical address**
- 平常使用，OS 需要將 Logical address 翻譯成 physical address 才可以使用
- 只有在 Absolute code 時，Logical ad
## Swapping
- 
## Contiguous Memory Allocation
- 
## Paging
- 
## Page Table
- 
## Segmentation
- 
