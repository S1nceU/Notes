## Overview
- CPU 利用率的基本單位
- 透過 API 創建、執行

### Single and Multithreaded Processes
![[Pasted image 20250929162440.png|400]]
- 共有 Code、Data、Files，同一做事情
### Benefits
+ Responsiveness : 反應好，當其中有執行續被中斷，則其他執行緒則會接上使用 CPU
+ Resource sharing : 有共同的位址空間
+ Economy : cost 比 process 還要高，process 需要做其餘轉換跟記憶體共享
+ Scalability : 可以有多個執行緒在 process 上，擴展性充足
## Multicore Programming
- Dividing activities : 區分執行的區塊
- Balance : 執行負載平衡
- Data splitting : 劃分程式使用的資料
- Data dependency : 需要等待別人使用完資料，達到資料獨立性
- Testing and debugging 
### User Threads and Kernel Threads
#### User threads
+ POSIX Pthreads, Win32 threads...
+ By user-level **threads library**

+ 比較快創建，因為不會碰到 system call
+ 如果 kernel 是單線程，就算 user 創幾個都沒用
#### Kernel threads
+ Windows 2000, Linux...
+ By **kernel**

+ 會相對比較慢
+ 獨立執行

## Multithreading Models
### Multithreading Models 
+ Many-to-One 
+ One-to-One
+ Many-to-Many

#### Many-to-One
+ Mapping to single kernel thread
+ 並非真正的多線程，因為不會創建其他 kernel 線程，無法做平行運算
+ 所以在單一線程做事情時，其他線程會阻塞
+ 創建線程相對快
+ 會有 block 的問題

#### One-to-One 
+ 可以同時，不會有阻塞問題
+ 會比較慢
+ User 創建的線程有數量限制
+ 資源開銷大

#### Many-to-Many
+ 沒有數量限制
+ 需要做排程，資源分配器分配工作
+ 會更慢

## Thread Libraries
- Pthread
- Windows Multithread 
- JAVA thread

- Creates -> Waits -> Closes
## Threading Issues
### fork() and exec()
+ 有些系統兩種 fork() 的方式都支援
	+ 直接複製一整個 process 
	+ 只複製該線程
+ execlp works the same; replace the entire process
### Thread Cancellation
+ Target thread : a thread that is to be cancelled
+ **Asynchronous cancellation** : 執行到一個階段做 clean up
+ **Deferred cancellation** : 等到一個 check point 做 clean up

### Signal Handling
+ 被特定事件產生
+ is delivered to a process 
+ handled

### Thread Pools
+ 創建一個數量的 threads，然後可以重複使用這些 threads

+ 處理一個服務速度會變得更快，因為不用多時間創建
+ 可以控制資源使用量
### Thread Specific Data
- 允許每個線程有自己資料的副本
## Opreating System Examples
