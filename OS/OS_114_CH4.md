- Overview
- Multicore Progamming
- Mutithreading Models
- Thread Libraries
- Threading Issues
- Opreating System Examples

## Overview
- CPU 利用率的基本單位
- 透過 API 創建、執行

### Single and Multithreaded Processes
![[Pasted image 20250929162440.png|400]]
- 共有 Code、Data、Files，同一做事情
### Benefits
+ Responsiveness : 反應好，當其中有執行續被中斷，則其他執行緒則會接上使用 CPU
+ Resource sharing : 有共同的位址空間
+ Economy : cost 比 process 還要高，process 需要做其餘轉換跟記憶體共享
+ Scalability : 可以有多個執行緒在 process 上，擴展性充足
## Multicore Programming
- Dividing activities : 區分執行的區塊
- Balance : 執行負載平衡
- Data splitting : 劃分程式使用的資料
- Data dependency : 需要等待別人使用完資料，達到資料獨立性
- Testing and debugging 
### User Threads and Kernel Threads
#### User threads
+ POSIX Pthreads, Win32 threads...
+ By user-level **threads library**

+ 比較快創建，因為不會碰到 system call
+ 如果 kernel 是單線程，就算 user 創幾個都沒用
#### Kernel threads
+ Windows 2000, Linux...
+ By **kernel**

+ 會相對比較慢
+ 獨立執行

## Multithreading Models
### Multithreading Models 
+ Many-to-One 
+ One-to-One
+ Many-to-Many

#### Mant-to-One
+ Mapping to single kernel thread
+ 並非真正的多線程，因為不會創建其他 kernel 線程，無法做平行運算
+ 所以在單一線程做事情時，其他線程會阻塞
+ 創建線程相對快
+ 會有 block 的問題

#### One-to-One 
+ 可以同時，不會有阻塞問題
+ 會比較慢
+ User 創建的線程有數量限制
+ 資源開銷大

#### Many-to-Many
+ 沒有數量限制
+ 需要做排程，資源分配器分配工作
+ 會更慢

## Thread Libraries

## Threading Issues

## Opreating System Examples
