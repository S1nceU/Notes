## Background
- 當共享數據時，可能會導致資料不一致
### Race Condition
![[Pasted image 20251026162214.png|300]]
- 當兩件事情同時做時，會造成資料不一致的衝突
## Critical-Section Problem
- 每個 Process 都有一個 CS
	![[Pasted image 20251026162722.png|300]]
	- entry section : 
		- used for access control
		- make sure only one process can enter crtical section

### 怎麼撰寫 entry，有三種標準情況
1. **Mutual Exclusion** : 只有一個 process 可以在 CS 執行
	- 同時只會有一個 CS 執行
2. **Progress** : 要確保空的時候可以進去，且可以正常執行
3. **Bounded Waiting** : 等待的時間是要**有限**的
	- 以防 starvation

## Peterson's Solution
- 僅支援兩個 process
- 假設 Load 跟 Store 指令是 atomic，不能被中斷
- 兩個共享變數
	- int turn 表示換該 process 執行
	- Boolean flag\[2] 表示是否要進入 CS
	![[Pasted image 20251026164850.png|300]]
- 輪流的概念可以達成 Bounded Waiting 的條件
## Synchronization Hardware
- 硬體解決方案
- 用物理的 "鎖" 保護
+ atomic instructions
	+ **atomic** : 必須一次做完
	+ as one uninterrupt unit 
	+ TestAndSet (var.), Swap (a,b)
+ **test_and_set**
	+ lock **false** mean unlocked
	![[Pasted image 20251026194800.png|300]]
	![[Pasted image 20251026194540.png|300]]
- **compare_and_swap**
	![[Pasted image 20251026195040.png|300]]
	![[Pasted image 20251026195103.png|300]]
	![[Pasted image 20251026195201.png|300]]

## Semaphores
- 是一個共享的變數
- wait() 以及 signal()
	![[Pasted image 20251026195822.png|300]]
	![[Pasted image 20251026195839.png|300]]
	- 有人在用，代表 S 沒有工作空間，所以等於 0，用完後還給系統，所以 S++
- Counting semaphore
	- 用於資源管理
	- 範圍可以是不受限制的區域
- Binary semaphore 
	- 只有 0 以及 1
	- Mutex lock

### Semaphore Implementation
- 必須確保在同一時間上，不會有人同時執行 wait() 或是 signal()
- 一直用 while 迴圈等待 ( spin lock )，會導致 CPU 執行卡住，則會造成 busy waiting

- 所以設計可以把它們放進 waiting queue
- waiting queue item
	- value
		- 還有多少個 semaphore 可以用
		- 如果是負數，則代表有人已在等待
	- pointer to next record in the list
		- 找下一個等待的 process
- block()
	- 將 process 放進 waiting queue
	- 如果要等待，可以使它休眠
- wakeup()
	- 有人從 CS 離開，則將下一個 process 喚醒，放進 CS
![[Pasted image 20251026202104.png|300]]

## Class Problems of Synchronization
### Deadlock and Starvation
- Deadlock 
	- 兩個 Processes 都在無限期的互相等待，等待不會發生的事情
	- 永遠無法進入 CS
	![[Pasted image 20251110165940.png|500]]
- Starvation
	- 排程中有從未被選到的 process 
- Priority Inversion
	- 低優先的 process 占用高優先的 process
	- Solved via **priority-inheritance protocol**
		- 當 lock 發生的時候，繼承高優先的屬性移至低優先的 process

### Bounded-Buffer Problem
![[Pasted image 20251110192518.png|500]]
#### Producer
![[Pasted image 20251110192828.png|500]]
#### consumer
![[Pasted image 20251110192848.png|500]]
### Readers and Writers Problem
- Reader
	- 只能讀取資料
- Writer
	- 可以讀寫
	- 同時只能有一個人寫入資料
- **First Problem**
	- 有很多 Reader 以及 Writer，在 Reader 讀取資料時，Writer 要先讓 Reader 讀取，可能造成 Writer 會 Starvation
	- Solution
		- rw_mutex 
			- 檢查是否要寫入
			- 管理**第一個 reader** 是否可以讀取資料，或是**最後一個 reader** 是否離開
		- mutex
			- 用來保護 read_count 這個變數
		- read_count
			- 表示有多少 reader 在讀取資料
		![[Pasted image 20251110195226.png]]
- **Second Problem**
	- 如果有一個正在等待的 Writer，則不允許新的 Reader 進入 CS，但允許之前的 Reader 離開 CS
	- Reader 可能 Starvation

### Dining-Philosophers Problem
![[Pasted image 20251110200219.png|500]]
- 筷子是 Semaphore，可以用 semaphore 確認筷子是否可用
![[Pasted image 20251110200400.png|500]]
- Deadlock 產生
![[Pasted image 20251110200547.png|500]]
- Solution
	1. 在 n 個人當中，最多只能有 n-1 的人可以使用 CPU
	2. 一次就直接拿兩根筷子，否則都不能拿
		- 兩根筷子都可用的情況下，才拿起筷子
	3. 編號所有的人，奇數編號的先從左邊拿到筷子，再拿右邊，偶數則相反
## Monitors
![[Pasted image 20251110201531.png|500]]
- 提供一種處理進程同步的便捷方法
- 實作一次最多一個 thread 執行特定的 subrountine
- 一次只有一個程是可以存取 monitors
- Condition x, y
- Operation
	- x.wait()
		- Process 會暫停，等待 Signal
	- x.signal()
		- x 條件中挑選出一個 process，如果 x 是空的則不會有任何影響
		- 不會喚醒
## A Deadlock-free Monitor Solution
- Data structure
	- State
		- 表示 philosopher 的狀態
		- thinking, hungry, eating
	- Self
		- Condition variable
		- 是要等待或是 signal
- Operation
	- pickup
		- 拿起筷子
	- putdown
		- 放下筷子
![[Pasted image 20251110204746.png|500]]
![[Pasted image 20251110204937.png|500]]


