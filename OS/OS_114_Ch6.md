## Background
- 當共享數據時，可能會導致資料不一致
### Race Condition
![[Pasted image 20251026162214.png|300]]
- 當兩件事情同時做時，會造成資料不一致的衝突
## Critical-Section Problem
- 每個 Process 都有一個 CS
	![[Pasted image 20251026162722.png|300]]
	- entry section : 
		- used for access control
		- make sure only one process can enter crtical section

### 怎麼撰寫 entry，有三種標準情況
1. **Mutual Exclusion** : 只有一個 process 可以在 CS 執行
	- 同時只會有一個 CS 執行
2. **Progress** : 要確保空的時候可以進去，且可以正常執行
3. **Bounded Waiting** : 等待的時間是要**有限**的
	- 以防 starvation

## Peterson's Solution
- 僅支援兩個 process
- 假設 Load 跟 Store 指令是 atomic，不能被中斷
- 兩個共享變數
	- int turn 表示換該 process 執行
	- Boolean flag\[2] 表示是否要進入 CS
	![[Pasted image 20251026164850.png|300]]
- 輪流的概念可以達成 Bounded Waiting 的條件
## Synchronization Hardware
- 硬體解決方案
- 用物理的 "鎖" 保護
+ atomic instructions
	+ **atomic** : 必須一次做完
	+ as one uninterrupt unit 
	+ TestAndSet (var.), Swap (a,b)
+ **test_and_set**
	+ lock **false** mean unlocked
	![[Pasted image 20251026194800.png|300]]
	![[Pasted image 20251026194540.png|300]]
- **compare_and_swap**
	![[Pasted image 20251026195040.png|300]]
	![[Pasted image 20251026195103.png|300]]
	![[Pasted image 20251026195201.png|300]]

## Semaphores
- 是一個共享的變數
- wait() 以及 signal()
	![[Pasted image 20251026195822.png|300]]
	![[Pasted image 20251026195839.png|300]]
	- 有人在用，代表 S 沒有工作空間，所以等於 0，用完後還給系統，所以 S++
- Counting semaphore
	- 用於資源管理
	- 範圍可以是不受限制的區域
- Binary semaphore 
	- 只有 0 以及 1
	- Mutex lock

### Semaphore Implementation
- 必須確保在同一時間上，不會有人同時執行 wait() 或是 signal()
- 一直用 while 迴圈等待 ( spin lock )，會導致 CPU 執行卡住，則會造成 busy waiting

- 所以設計可以把它們放進 waiting queue
- waiting queue item
	- value
		- 還有多少個 semaphore 可以用
		- 如果是負數，則代表有人已在等待
	- pointer to next record in the list
		- 找下一個等待的 process
- block()
	- 將 process 放進 waiting queue
	- 如果要等待，可以使它休眠
- wakeup()
	- 有人從 CS 離開，則將下一個 process 喚醒，放進 CS
![[Pasted image 20251026202104.png|300]]

## Class Problems of Synchronization
## Monitors
## Synchronization examples
## Atomic transactions
