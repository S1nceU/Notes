- File System
# Interface
## File Concept
- File 
	- a logical storage unit create by OS
	- Type 
		- Data
		- Program
- File attributes
	- File name
	- Identifier
		- unique tag or number by the file system
	- Type
	- Location
	- Size
		- byte
	- Protection
	- Time, date, and user identification
		- time stamp
## File operations
- Operation
	- Create
	- Write
		- indicate where in the file the system will begin to write
	- Read
		- read a file that the system starts at the position indicated
	- Reposition within file
		- seek
		- 改寫 read/write 的位置
	- Delete
		- free up the space
	- Truncate/Concatenate
		- reduce the length of a file, splitting a file
		- concat two files together
- Open-file table
	- each process has an open-file table
	- track the files it has opened
	- 有讀寫位置、檔案權限
	- 每個 process 追蹤開啟檔案的表格
	
- System-wide table
	- a.k.a global file table
	- 包含所有 processes 打開的 file
	- 有多少 instance、多少 process 有打開檔案、file 的狀態以及屬性
	- 檔案的磁碟位置、存取權限、檔案被開啟的次數

![[Pasted image 20251215164202.png|500]]
- process 開檔案後，會在 system-wide table 尋找或是 register 一個
- 然後在到 open-file table register 
- 同一個檔案可以被多個 process 開啟，但需要 System-wide table 設定安全性、同步問題、跟蹤 process

## Access methods
### Sequential access
- Read/write next block
- Reset 
	- repositioning the file pointer to the beginning
- Skip/rewind $n$ records
	- 跳過或是倒帶
- Ex
	- Video tape
	- Cassette tape
### Direct (relative) access
- Access an element at a arbitrary (隨意的) position
- 用 block 編號指定需要訪問的資料位置
- 比較圖
![[Pasted image 20251215170813.png|500]]
### Index access
- 會有 pointer 指向檔案區塊
- 若檔案越大，則需要指向檔案中的內容就越多，則 index file 則會變大

![[Pasted image 20251215171555.png|500]]
## Directory structure
- Directory 是一組 nodes 的集合
- 作為索引，指向實際的檔案
- 會存在硬碟當中
- Operation
	- Search
	- Create 
	- Delete
	- List a directory
	- Rename
	- Traverse the file system
		- 遍歷檔案系統
### Single-level directory
- 所有資料的索引都存在一個 single directory
![[Pasted image 20251215175304.png|500]]
- Problem
	- Naming
		- 不能有同樣的檔名，檔名全域唯一
	- Grouping
		- 難以分類檔案，因為都在同一層
	- Poor efficiency
		- 檔案越多，要遍歷的 index 就越多，效率慢
- 易實作，體驗差
### Two-level directory
- 用使用者分層，解決同名以及效率差問題
- Master File Directory (MFD)、User File Directory (UFD)
![[Pasted image 20251215175830.png|500]]
- Problem
	- Grouping
		- 依然難解決資料分類問題
	- 單一使用者效率差
		- 在單一使用者資料變多，則該使用者的遍歷則會變慢
### Tree-structured directory
- 用樹結構，建造資料樹
![[Pasted image 20251215180805.png|500]]
- 多層目錄定義位置
- Path
	- Absolute 絕對
	- Relative 相對
- Operation
	- mkdir 創建子目錄
	- 刪除則會刪掉整個子樹
- 有分類的能力，管理成本低
- 因為可以分類多層，則可有效率的查詢
### Acyclic-graph directory
- 無環有序圖，不會有迴圈
![[Pasted image 20251215181206.png|500]]
- 讓不同專案可以共享目錄以及檔案
- Problem
	- 同一個檔案會有多條絕對路徑
	- 刪除檔案時，需要注意是否還有其他條路徑指向檔案，否則會報檔案遺失或是 memory leak
		- 可以用一個 counter 做為指向的數量，為 0 時才可以完全刪除檔案
### General-graph directory
- 有環有序圖，可能有迴圈
![[Pasted image 20251215205756.png|500]]
- 允許檔案互相指向，但可能會有 cycle
- Problem
	- Cycle
		- 導致路徑解析時會有無限迴圈
		- 在刪除檔案時，Refence Counter 不會有 0 的時候，導致無法刪除
	- 解決辦法
		- Garbage collection
			- 用定期機制判定是否有檔案節點無法被訪問或到達，可以防止循環中有洞
		- Cycle detection
			- 建立連結的時候，用演算法判定是否有 Cycle，若有則拒絕
## File-System Mounting
- 一個 File system 需要訪問時，需要先被 Mounting
![[Pasted image 20251215211243.png|500]]
- Mounting
	- 將一個 File system 接上在主目錄的一個節點中 (Mount Point)
- Timing
	- Boot time
		- 開機時，自動掛載
	- Automatically at run-time
		- 執行中自動掛載，插 USB 等
	- Manually at run-time
		- 手動掛載，指定掛載點上，掛上自己的 File system
## File Sharing
- 在協作的工作環境、多使用者存取檔案時，會有 File sharing 的機制，管理權限與保護資料
- UID、GID
	- User ID
		- 以**人**的單位辨識權限
	- Group ID
		- 以使用者**群組**辨識權限
- Character
	- Owner
		- 擁有者能做
	- Group
		- 同一群組能做
	- Others
		- 都不屬於能做
## Access-Control and Group
![[Pasted image 20251215212452.png|200]]
![[Pasted image 20251215212505.png|300]]
- Access-Control List (ACL)
	- 檢查訪問請求是否符合權限
	- RWX：Read、Write、eXecute
- 每個檔案會有三組 ACL
	- Owner、Group、Public/Others
- ACL 可以用二進制轉十進制
	- 7 = 4 + 2 + 1 = rwx
	- 6 = 4+2+0 = rw
	- 1 = 0+0+1 = --x
	- chmod 761 = rwxrw---x
- 第一個 d 的意思
	- 是否是**資料夾**
## File Protection
- File owner/creator 可以設定 ACL 存取權限，對於資料作保護政策
- 兩種風險
	- Physical damage 實體損壞 (Reliability)
		- 磁軌、硬碟損毀
		- 可以用 RAID 做保護機制
	- Improper acces 不當存取 (Protection)
		- 有未授權的人讀到機密檔案竄改
		- 可以用驗證機制加上 ACL 阻止事情發生
# Implementation

## File-System Structure
### File structure
- Logical storage unit
	- 對於使用者，File 是一個可命名、可存取的資料單位
- Collection of relate information
	- File 的屬性被包在一起
### File system 
- 主要目的是提供一個 UI 可以映射 logical address to physical address
- 提供一種高效的方式儲存、定位、搜索**硬碟**上的資料
### I/O unit
- a block 是硬碟上的單位
- 一個 block 會有一個或多個 sector
- 一個 sector 約莫 512 bytes
- sector 是硬碟上最小的 physical storage 單位
### Layered File System
- Application programs
	- 提供 API，讓程式用統一的方法操作檔案，ex. `Open/Close/Read/Write`
- Logical file system
	- 管理目錄結構與檔案 metadata，像是權限、擁有者、time stamp、大小
	- 把**檔名**解析成能定位檔案的控制資訊，檔名 $\rightarrow$ inode
	- 同時處理 directory management 以及 **protection**
- File organization module
	- 負責映射 logical block 到 physical block
	- 管理 free space 以及 disk allocation
- Basic file system
	- 接收較低階的需求，**取回某個 block**，轉換成更接近裝置層可執行的 I/O request
- I/O control + Device
	- 用 device driver 去跟硬體溝通，將讀寫命令傳給 Device
## File-System Implementation
- File System API 的結構
	- On-disk structures
		- 在磁碟永久保存
	- In-memory structures
		- 執行時加速用
### On-Disk Structure
- Boot control block
	- OS 靠這個 block 來開啟系統
	- 像是 UFS boot block、NTFS partition boot sector
- Volume control block
	- a.k.a partition control block
	- 存放整個 volume 的資訊
		- 總 block 數
		- 空閒 block 數
		- block size
		- free-space
	- 像是 UFS 的 superblock、NTFS 的 master file table (MFT)
- Directory structure
	- 可以是樹狀結構等
	- 用於對應**檔名**與**識別資訊(inode)**
	- 做於路徑解析
- File Control Block (FCB)
	- 存單一檔案的細節屬性，inode、ACL、size、date
	- **檔案資料在哪些 data blocks** 或是**指向資料區塊的 pointers**
	![[Pasted image 20251221004106.png|200]]
### In-Memory Structure
- In-memory partition table
	- 存放每個 **mounted** 的區，讓 OS 知道哪些 file system 可以用
- In-memory directory structure
	- 不需要載入所有的路徑
	- 存取**最近存取過的目錄**資訊，讓路徑解析更快
- System-wide open-file table
	- 針對每個已經開啟的檔案保存一份對應的 FCB 副本
	- 避免重複打 disk
- Per-process open-file table
	- 每個 process 自己的 table，**存放 file descriptor/handle**，以及**指向 system-wide open-file table 對應 entry 的指標**
### File Open/Read
![[Pasted image 20251221005227.png|500]]
- Linear List
	- 目錄有一個 list 存放，每個元素指向檔案資料的 block 或 inode
	- 優點
		- 好寫、結構簡單
	- 缺點
		- 效率低，搜尋太慢
	- 改良
		- 可以用 B+ tree 改善或是依照字母排序
- Hash table
	- 改用 hash 結構存放檔名
	- 優點
		- 減少搜尋時間
	- 缺點
		- 可能會有碰撞問題
		- 在 entry 大小固定時，效率最穩

## Allocation Methods
- How to allocate block
### Contiguous allocation
- 每個檔案會占用一串連續的 block
- 描述檔案位置的兩個 para
	- starting block (block \#)
	- length
- 可以用於 Sequential 或是 Randon access
- 優點
	- 效能好，因為可以連著讀取，並且可以直接定位
- 缺點
	- External fragmentation 問題
		- 會有很多 hole 產生
	- Finding space for file
		- 可能很難搜尋足夠大的空間
	- Knowing file size
		- 要事先知道檔案大小
	- File cannot grow
		- 無法自由的讓檔案變大，因為後續的空間可能已經被占走了
		- 甚至要重新分配資料位置
### Linked allocation
- 每個 block 都會存一個 pointer 指向下一個 block，最後一個指向 nil
- block 可以散布各地，所以可以解決 external fragmentation 問題
- 優點
	- 檔案可以自由變大
	- 沒有 external fragmentation
- 缺點
	- Random access 會很慢
		- 想要第 X 個 block 需要從頭開始沿著 pointer 搜尋
	- 定位第 X 個 block 成本高
		- 需要多次的搜尋，沿著 pointer 走
		- I/O 的次數變多，則成本變高
	- Pointer 會佔空間
		- 導致每個 block 都會有空間損失
	- Reliability 問題
		- 如果一個資料有一個 block 損壞，則會造成資料不完整或整個損毀
### Indexed allocation
- 會有一個 index table 存放 pointer，指向 data
- 讀檔案時，會先讀取 index table，指向 data，然後再讀取 data
- 優點
	- direct access 或是 random access 的效率好
	- 只要有空區塊，任何需要的檔案都可以使用
		- 因為一個檔案一個 table，所以只要更新 table 就好
- 缺點
	- Space required for index table
		- 每個檔案都需要額外的空間存放 index table
		- 小檔案一變多，則額外空間也會變多
	- Multiple index tables issue
		- 如果檔案很大，data block 太多，則會因為 index block 放不下，而造成額外開銷
![[Pasted image 20251221020404.png|300]]
- 19 是 index block 的 pointer
- 裡面有 index table
## Free-Space Management
### Bit vector 
- 會有一個 bit vector 或是 bit map 紀錄每個磁碟上每個 block 的狀態
- 優點
	- 對於 contriguous allocation 需要連續空間的演算法，有很好發揮空間
- 缺點
	- 這個 state vector 會佔額外空間
### Linked list 
- a.k.a Linked allocation
- 只用一個 pointer 指向 free list head
- 這個 link list 的每個元素都指向一個 free 的空間
- 優點
	- 不會浪費額外太多空間，則可以找到 free space
- 缺點
	- 不容易拿到連續空間
		- 除非連號，否則不會有連續的 free space
	- 訪問很慢
		- 要沿著 pointer 走
	- Reliability 
		- 某個空的 block 壞掉或是指標被寫壞
		- 則會造成 link list 斷掉，管理結構損毀
### Grouping
- a.k.a Linked index allocation
- 用一個 block 當作 index page，存放 free space 的 index
- 就像是 index table
- 流程
	- 先找第一個空 block，把它當成 **grouping block**
	- 這個 grouping block 內有 **n 個 entries**
		- 前 **(n−1)** 個 entry：直接存「哪些 blocks 是空的」（free blocks 的 index）
		- 最後 1 個 entry：指向「下一個 grouping block」（下一頁索引）
- 不會有 list 問題
- 一次就可以拿到一大批 free blocks，
### Counting
- a.k.a Contiguous allocation
- free space 會用一個 index 以及 length 的表示
	- (17, 5)，代表從 17 開始有 5 個空閒位置，17、18、19、20、21 是空的
- 對於連續空間，省記憶體也容易找 contiguous space


